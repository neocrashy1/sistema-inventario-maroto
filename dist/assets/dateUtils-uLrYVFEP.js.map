{"version":3,"file":"dateUtils-uLrYVFEP.js","sources":["../../src/utils/dateUtils.js"],"sourcesContent":["/**\nimport logger from '@/utils/logger'\n * Utilitários para manipulação e validação de datas\n */\n\n/**\n * Formata uma data para o padrão brasileiro (DD/MM/AAAA)\n * @param {string|Date} date - Data a ser formatada\n * @returns {string} Data formatada ou string vazia se inválida\n */\nexport function formatDate(date) {\n  if (!date) return '';\n  \n  try {\n    const dateObj = typeof date === 'string' ? new Date(date) : date;\n    \n    if (isNaN(dateObj.getTime())) {\n      return '';\n    }\n    \n    return dateObj.toLocaleDateString('pt-BR', {\n      day: '2-digit',\n      month: '2-digit',\n      year: 'numeric'\n    });\n  } catch (error) {\n    logger.error('Erro ao formatar data:', error);\n    return '';\n  }\n}\n\n/**\n * Formata uma data para exibição completa (dia da semana, DD de mês de AAAA)\n * @param {string|Date} date - Data a ser formatada\n * @returns {string} Data formatada ou string vazia se inválida\n */\nexport function formatDateLong(date) {\n  if (!date) return '';\n  \n  try {\n    const dateObj = typeof date === 'string' ? new Date(date) : date;\n    \n    if (isNaN(dateObj.getTime())) {\n      return '';\n    }\n    \n    return dateObj.toLocaleDateString('pt-BR', {\n      weekday: 'long',\n      day: 'numeric',\n      month: 'long',\n      year: 'numeric'\n    });\n  } catch (error) {\n    logger.error('Erro ao formatar data:', error);\n    return '';\n  }\n}\n\n/**\n * Valida se uma data é válida\n * @param {string|Date} date - Data a ser validada\n * @returns {boolean} True se a data for válida\n */\nexport function isValidDate(date) {\n  if (!date) return false;\n  \n  try {\n    const dateObj = typeof date === 'string' ? new Date(date) : date;\n    return !isNaN(dateObj.getTime());\n  } catch (error) {\n    return false;\n  }\n}\n\n/**\n * Verifica se uma data está no passado\n * @param {string|Date} date - Data a ser verificada\n * @returns {boolean} True se a data estiver no passado\n */\nexport function isDateInPast(date) {\n  if (!isValidDate(date)) return false;\n  \n  const dateObj = typeof date === 'string' ? new Date(date) : date;\n  const today = new Date();\n  today.setHours(0, 0, 0, 0);\n  \n  return dateObj < today;\n}\n\n/**\n * Verifica se uma data está no futuro\n * @param {string|Date} date - Data a ser verificada\n * @returns {boolean} True se a data estiver no futuro\n */\nexport function isDateInFuture(date) {\n  if (!isValidDate(date)) return false;\n  \n  const dateObj = typeof date === 'string' ? new Date(date) : date;\n  const today = new Date();\n  today.setHours(23, 59, 59, 999);\n  \n  return dateObj > today;\n}\n\n/**\n * Calcula a diferença em dias entre duas datas\n * @param {string|Date} date1 - Primeira data\n * @param {string|Date} date2 - Segunda data\n * @returns {number} Diferença em dias (positivo se date1 > date2)\n */\nexport function daysDifference(date1, date2) {\n  if (!isValidDate(date1) || !isValidDate(date2)) return 0;\n  \n  const dateObj1 = typeof date1 === 'string' ? new Date(date1) : date1;\n  const dateObj2 = typeof date2 === 'string' ? new Date(date2) : date2;\n  \n  const timeDiff = dateObj1.getTime() - dateObj2.getTime();\n  return Math.ceil(timeDiff / (1000 * 3600 * 24));\n}\n\n/**\n * Adiciona dias a uma data\n * @param {string|Date} date - Data base\n * @param {number} days - Número de dias a adicionar\n * @returns {Date|null} Nova data ou null se inválida\n */\nexport function addDays(date, days) {\n  if (!isValidDate(date)) return null;\n  \n  const dateObj = typeof date === 'string' ? new Date(date) : new Date(date);\n  dateObj.setDate(dateObj.getDate() + days);\n  \n  return dateObj;\n}\n\n/**\n * Converte uma string de data no formato DD/MM/AAAA para AAAA-MM-DD\n * @param {string} dateStr - Data no formato DD/MM/AAAA\n * @returns {string} Data no formato AAAA-MM-DD ou string vazia se inválida\n */\nexport function convertBrDateToIso(dateStr) {\n  if (!dateStr) return '';\n  \n  try {\n    const parts = dateStr.split('/');\n    if (parts.length !== 3) return '';\n    \n    const [day, month, year] = parts;\n    const isoDate = `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;\n    \n    // Valida se a data é válida\n    if (isValidDate(isoDate)) {\n      return isoDate;\n    }\n    \n    return '';\n  } catch (error) {\n    logger.error('Erro ao converter data:', error);\n    return '';\n  }\n}\n\n/**\n * Converte uma string de data no formato AAAA-MM-DD para DD/MM/AAAA\n * @param {string} dateStr - Data no formato AAAA-MM-DD\n * @returns {string} Data no formato DD/MM/AAAA ou string vazia se inválida\n */\nexport function convertIsoDateToBr(dateStr) {\n  if (!dateStr) return '';\n  \n  try {\n    const parts = dateStr.split('-');\n    if (parts.length !== 3) return '';\n    \n    const [year, month, day] = parts;\n    return `${day.padStart(2, '0')}/${month.padStart(2, '0')}/${year}`;\n  } catch (error) {\n    logger.error('Erro ao converter data:', error);\n    return '';\n  }\n}\n\nexport function formatDateTime(date, options = { withSeconds: false }) {\n  if (!date) return '';\n  try {\n    const d = typeof date === 'string' ? new Date(date) : date;\n    if (isNaN(d.getTime())) return '';\n    const base = {\n      day: '2-digit',\n      month: '2-digit',\n      year: 'numeric',\n      hour: '2-digit',\n      minute: '2-digit'\n    };\n    if (options?.withSeconds) base.second = '2-digit';\n    return d.toLocaleString('pt-BR', base);\n  } catch (error) {\n    logger.error('Erro ao formatar data/hora:', error);\n    return '';\n  }\n}\n\nexport function formatTimeAgo(date) {\n  if (!isValidDate(date)) return '';\n  try {\n    const d = typeof date === 'string' ? new Date(date) : date;\n    const diffMs = Date.now() - d.getTime();\n    const diffSec = Math.floor(diffMs / 1000);\n    if (diffSec < 5) return 'agora';\n    if (diffSec < 60) return `há ${diffSec}s`;\n    const diffMin = Math.floor(diffSec / 60);\n    if (diffMin < 60) return `há ${diffMin} min`;\n    const diffHours = Math.floor(diffMin / 60);\n    if (diffHours < 24) return `há ${diffHours} h`;\n    const diffDays = Math.floor(diffHours / 24);\n    return `há ${diffDays} d`;\n  } catch (error) {\n    logger.error('Erro ao calcular tempo relativo:', error);\n    return '';\n  }\n}"],"names":["isValidDate","date","dateObj","Date","isNaN","getTime","error","daysDifference","date1","date2","dateObj1","dateObj2","timeDiff","Math","ceil","formatDateTime","options","withSeconds","d","base","day","month","year","hour","minute","second","toLocaleString","logger"],"mappings":"AA+DO,SAASA,EAAYC,GAC1B,IAAKA,EAAM,OAAO,EAElB,IACE,MAAMC,EAA0B,iBAATD,EAAoB,IAAIE,KAAKF,GAAQA,EAC5D,OAAQG,MAAMF,EAAQG,UACxB,OAASC,GACP,OAAO,CACT,CACF,CAsCO,SAASC,EAAeC,EAAOC,GACpC,IAAKT,EAAYQ,KAAWR,EAAYS,GAAQ,OAAO,EAEvD,MAAMC,EAA4B,iBAAVF,EAAqB,IAAIL,KAAKK,GAASA,EACzDG,EAA4B,iBAAVF,EAAqB,IAAIN,KAAKM,GAASA,EAEzDG,EAAWF,EAASL,UAAYM,EAASN,UAC/C,OAAOQ,KAAKC,KAAKF,EAAA,MACnB,CAgEO,SAASG,EAAed,EAAMe,EAAU,CAAEC,aAAa,IAC5D,IAAKhB,EAAM,MAAO,GAClB,IACE,MAAMiB,EAAoB,iBAATjB,EAAoB,IAAIE,KAAKF,GAAQA,EACtD,GAAIG,MAAMc,EAAEb,WAAY,MAAO,GAC/B,MAAMc,EAAO,CACXC,IAAK,UACLC,MAAO,UACPC,KAAM,UACNC,KAAM,UACNC,OAAQ,WAGV,OADI,MAAAR,OAAA,EAAAA,EAASC,eAAaE,EAAKM,OAAS,WACjCP,EAAEQ,eAAe,QAASP,EACnC,OAASb,GAEP,OADAqB,OAAOrB,MAAM,8BAA+BA,GACrC,EACT,CACF"}