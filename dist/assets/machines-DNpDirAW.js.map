{"version":3,"file":"machines-DNpDirAW.js","sources":["../../src/services/websocket.js","../../src/stores/machines.js"],"sourcesContent":["import logger from '@/utils/logger'\n\nclass WebSocketService {\n  constructor() {\n    this.ws = null\n    this.url = null\n    this.reconnectAttempts = 0\n    this.maxReconnectAttempts = 5\n    this.reconnectInterval = 3000\n    this.isConnecting = false\n    this.isManualClose = false\n    this.listeners = new Map()\n    this.heartbeatInterval = null\n    this.heartbeatTimeout = null\n    this.lastHeartbeat = null\n    \n    // Configurações\n    this.config = {\n      heartbeatInterval: 30000, // 30 segundos\n      heartbeatTimeout: 5000,   // 5 segundos para resposta\n      reconnectDelay: 3000,     // 3 segundos entre tentativas\n      maxReconnectAttempts: 5\n    }\n  }\n\n  /**\n   * Conecta ao WebSocket\n   * @param {string} url - URL do WebSocket\n   * @param {Object} options - Opções de conexão\n   */\n  connect(url = 'ws://localhost:8000/api/v1/ws', options = {}) {\n    if (this.isConnecting || (this.ws && this.ws.readyState === WebSocket.CONNECTING)) {\n      logger.warn('WebSocket já está conectando')\n      return Promise.resolve()\n    }\n\n    if (this.ws && this.ws.readyState === WebSocket.OPEN) {\n      logger.warn('WebSocket já está conectado')\n      return Promise.resolve()\n    }\n\n    this.url = url\n    this.isConnecting = true\n    this.isManualClose = false\n\n    return new Promise((resolve, reject) => {\n      try {\n        logger.info(`Conectando ao WebSocket: ${url}`)\n        this.ws = new WebSocket(url)\n\n        // Timeout para conexão\n        const connectionTimeout = setTimeout(() => {\n          if (this.ws.readyState === WebSocket.CONNECTING) {\n            this.ws.close()\n            reject(new Error('Timeout na conexão WebSocket'))\n          }\n        }, options.timeout || 10000)\n\n        this.ws.onopen = (event) => {\n          clearTimeout(connectionTimeout)\n          this.isConnecting = false\n          this.reconnectAttempts = 0\n          \n          logger.info('WebSocket conectado com sucesso')\n          this.emit('connected', { event })\n          this.startHeartbeat()\n          resolve()\n        }\n\n        this.ws.onmessage = (event) => {\n          try {\n            const data = JSON.parse(event.data)\n            this.handleMessage(data)\n          } catch (error) {\n            logger.error('Erro ao processar mensagem WebSocket:', error)\n            this.emit('error', { error, rawData: event.data })\n          }\n        }\n\n        this.ws.onclose = (event) => {\n          clearTimeout(connectionTimeout)\n          this.isConnecting = false\n          this.stopHeartbeat()\n          \n          logger.info(`WebSocket desconectado. Code: ${event.code}, Reason: ${event.reason}`)\n          this.emit('disconnected', { event })\n\n          if (!this.isManualClose && this.shouldReconnect()) {\n            this.scheduleReconnect()\n          }\n        }\n\n        this.ws.onerror = (error) => {\n          clearTimeout(connectionTimeout)\n          this.isConnecting = false\n          \n          logger.error('Erro no WebSocket:', error)\n          this.emit('error', { error })\n          \n          if (this.ws.readyState === WebSocket.CONNECTING) {\n            reject(error)\n          }\n        }\n\n      } catch (error) {\n        this.isConnecting = false\n        logger.error('Erro ao criar WebSocket:', error)\n        reject(error)\n      }\n    })\n  }\n\n  /**\n   * Desconecta do WebSocket\n   */\n  disconnect() {\n    this.isManualClose = true\n    this.stopHeartbeat()\n    \n    if (this.ws) {\n      if (this.ws.readyState === WebSocket.OPEN || this.ws.readyState === WebSocket.CONNECTING) {\n        this.ws.close(1000, 'Desconexão manual')\n      }\n      this.ws = null\n    }\n    \n    logger.info('WebSocket desconectado manualmente')\n  }\n\n  /**\n   * Envia mensagem via WebSocket\n   * @param {string} type - Tipo da mensagem\n   * @param {Object} data - Dados da mensagem\n   */\n  send(type, data = {}) {\n    if (!this.isConnected()) {\n      logger.warn('WebSocket não está conectado. Mensagem não enviada:', { type, data })\n      return false\n    }\n\n    try {\n      const message = {\n        type,\n        data,\n        timestamp: Date.now()\n      }\n      \n      this.ws.send(JSON.stringify(message))\n      logger.debug('Mensagem enviada via WebSocket:', message)\n      return true\n    } catch (error) {\n      logger.error('Erro ao enviar mensagem WebSocket:', error)\n      this.emit('error', { error })\n      return false\n    }\n  }\n\n  /**\n   * Verifica se está conectado\n   */\n  isConnected() {\n    return this.ws && this.ws.readyState === WebSocket.OPEN\n  }\n\n  /**\n   * Adiciona listener para eventos\n   * @param {string} event - Nome do evento\n   * @param {Function} callback - Função callback\n   */\n  on(event, callback) {\n    if (!this.listeners.has(event)) {\n      this.listeners.set(event, new Set())\n    }\n    this.listeners.get(event).add(callback)\n  }\n\n  /**\n   * Remove listener de evento\n   * @param {string} event - Nome do evento\n   * @param {Function} callback - Função callback\n   */\n  off(event, callback) {\n    if (this.listeners.has(event)) {\n      this.listeners.get(event).delete(callback)\n    }\n  }\n\n  /**\n   * Emite evento para listeners\n   * @param {string} event - Nome do evento\n   * @param {Object} data - Dados do evento\n   */\n  emit(event, data = {}) {\n    if (this.listeners.has(event)) {\n      this.listeners.get(event).forEach(callback => {\n        try {\n          callback(data)\n        } catch (error) {\n          logger.error(`Erro no listener do evento ${event}:`, error)\n        }\n      })\n    }\n  }\n\n  /**\n   * Processa mensagens recebidas\n   * @param {Object} data - Dados da mensagem\n   */\n  handleMessage(data) {\n    const { type, data: messageData, timestamp } = data\n\n    // Resposta ao heartbeat\n    if (type === 'pong') {\n      this.handleHeartbeatResponse()\n      return\n    }\n\n    // Log da mensagem recebida\n    logger.debug('Mensagem recebida via WebSocket:', data)\n\n    // Emite evento específico do tipo\n    this.emit(type, { data: messageData, timestamp })\n    \n    // Emite evento genérico de mensagem\n    this.emit('message', data)\n  }\n\n  /**\n   * Inicia heartbeat\n   */\n  startHeartbeat() {\n    this.stopHeartbeat()\n    \n    this.heartbeatInterval = setInterval(() => {\n      if (this.isConnected()) {\n        this.lastHeartbeat = Date.now()\n        this.send('ping')\n        \n        // Timeout para resposta do heartbeat\n        this.heartbeatTimeout = setTimeout(() => {\n          logger.warn('Heartbeat timeout - reconectando...')\n          this.ws.close(1006, 'Heartbeat timeout')\n        }, this.config.heartbeatTimeout)\n      }\n    }, this.config.heartbeatInterval)\n  }\n\n  /**\n   * Para heartbeat\n   */\n  stopHeartbeat() {\n    if (this.heartbeatInterval) {\n      clearInterval(this.heartbeatInterval)\n      this.heartbeatInterval = null\n    }\n    \n    if (this.heartbeatTimeout) {\n      clearTimeout(this.heartbeatTimeout)\n      this.heartbeatTimeout = null\n    }\n  }\n\n  /**\n   * Processa resposta do heartbeat\n   */\n  handleHeartbeatResponse() {\n    if (this.heartbeatTimeout) {\n      clearTimeout(this.heartbeatTimeout)\n      this.heartbeatTimeout = null\n    }\n    \n    const latency = Date.now() - this.lastHeartbeat\n    this.emit('heartbeat', { latency })\n  }\n\n  /**\n   * Verifica se deve reconectar\n   */\n  shouldReconnect() {\n    return this.reconnectAttempts < this.config.maxReconnectAttempts\n  }\n\n  /**\n   * Agenda reconexão\n   */\n  scheduleReconnect() {\n    if (!this.shouldReconnect()) {\n      logger.error('Máximo de tentativas de reconexão atingido')\n      this.emit('maxReconnectAttemptsReached')\n      return\n    }\n\n    this.reconnectAttempts++\n    const delay = this.config.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1) // Backoff exponencial\n    \n    logger.info(`Tentativa de reconexão ${this.reconnectAttempts}/${this.config.maxReconnectAttempts} em ${delay}ms`)\n    \n    setTimeout(() => {\n      if (!this.isManualClose) {\n        this.connect(this.url).catch(error => {\n          logger.error('Erro na tentativa de reconexão:', error)\n        })\n      }\n    }, delay)\n  }\n\n  /**\n   * Obtém estatísticas da conexão\n   */\n  getStats() {\n    return {\n      isConnected: this.isConnected(),\n      reconnectAttempts: this.reconnectAttempts,\n      lastHeartbeat: this.lastHeartbeat,\n      url: this.url,\n      readyState: this.ws ? this.ws.readyState : null,\n      listeners: Array.from(this.listeners.keys())\n    }\n  }\n}\n\n// Instância singleton\nconst websocketService = new WebSocketService()\n\nexport default websocketService","import { ref, computed } from 'vue'\nimport { defineStore } from 'pinia'\nimport { machinesAPI, cachedAPI, handleAPIError } from '@/services/api'\nimport websocketService from '@/services/websocket'\nimport logger from '@/utils/logger'\nimport { useAuthStore } from './auth'\n\nexport const useMachinesStore = defineStore('machines', () => {\n  // Estado reativo\n  const machines = ref([])\n  const selectedMachine = ref(null)\n  const loading = ref(false)\n  const error = ref(null)\n  const lastUpdate = ref(null)\n  \n  // Estado de conexão WebSocket\n  const wsConnected = ref(false)\n  const wsError = ref(null)\n  \n  // Filtros e configurações\n  const filters = ref({\n    status: 'all', // all, online, offline, warning, critical\n    location: '',\n    department: '',\n    search: ''\n  })\n  \n  // Configurações de monitoramento\n  const monitoringConfig = ref({\n    autoRefresh: true,\n    refreshRate: 30000, // 30 segundos\n    realTimeUpdates: true,\n    alertsEnabled: true\n  })\n  \n  // Métricas agregadas\n  const metrics = ref({\n    totalMachines: 0,\n    onlineMachines: 0,\n    offlineMachines: 0,\n    warningMachines: 0,\n    criticalMachines: 0,\n    avgCpuUsage: 0,\n    avgMemoryUsage: 0,\n    avgDiskUsage: 0,\n    systemUptime: 0\n  })\n  \n  // Alertas de máquinas\n  const alerts = ref([])\n  \n  // Histórico de performance\n  const performanceHistory = ref({})\n  \n  // Computed properties\n  const filteredMachines = computed(() => {\n    let filtered = machines.value\n    \n    // Filtro por status\n    if (filters.value.status !== 'all') {\n      filtered = filtered.filter(machine => machine.status === filters.value.status)\n    }\n    \n    // Filtro por localização\n    if (filters.value.location) {\n      filtered = filtered.filter(machine => \n        machine.location?.toLowerCase().includes(filters.value.location.toLowerCase())\n      )\n    }\n    \n    // Filtro por departamento\n    if (filters.value.department) {\n      filtered = filtered.filter(machine => \n        machine.department?.toLowerCase().includes(filters.value.department.toLowerCase())\n      )\n    }\n    \n    // Filtro por busca\n    if (filters.value.search) {\n      const searchTerm = filters.value.search.toLowerCase()\n      filtered = filtered.filter(machine => \n        machine.name?.toLowerCase().includes(searchTerm) ||\n        machine.hostname?.toLowerCase().includes(searchTerm) ||\n        machine.ip?.includes(searchTerm) ||\n        machine.user?.toLowerCase().includes(searchTerm)\n      )\n    }\n    \n    return filtered\n  })\n  \n  const onlineMachines = computed(() => \n    machines.value.filter(machine => machine.status === 'online')\n  )\n  \n  const offlineMachines = computed(() => \n    machines.value.filter(machine => machine.status === 'offline')\n  )\n  \n  const criticalMachines = computed(() => \n    machines.value.filter(machine => machine.status === 'critical')\n  )\n  \n  const warningMachines = computed(() => \n    machines.value.filter(machine => machine.status === 'warning')\n  )\n  \n  // Actions\n  const fetchMachines = async (forceRefresh = false) => {\n    loading.value = true\n    error.value = null\n    \n    try {\n      const response = await cachedAPI.machines.getAll({\n        forceRefresh,\n        cacheKey: 'machines:all',\n        cacheTTL: 60000 // 1 minuto\n      })\n      \n      machines.value = response.data || []\n      updateMetrics()\n      lastUpdate.value = new Date()\n      \n      return { success: true, data: response.data }\n    } catch (err) {\n      const apiError = handleAPIError(err)\n      error.value = 'Erro ao carregar máquinas: ' + apiError.message\n      logger.error('Erro ao buscar máquinas:', err)\n      \n      // Fallback para dados mock em desenvolvimento\n      if (process.env.NODE_ENV === 'development') {\n        machines.value = generateMockMachines()\n        updateMetrics()\n        return { success: true, data: machines.value, mock: true }\n      }\n      \n      return { success: false, error: apiError.message }\n    } finally {\n      loading.value = false\n    }\n  }\n  \n  const fetchMachineStatus = async (machineId) => {\n    try {\n      const response = await cachedAPI.machines.getStatus(machineId, {\n        cacheKey: `machines:${machineId}:status`,\n        cacheTTL: 10000 // 10 segundos\n      })\n      \n      // Atualizar máquina específica na lista\n      const machineIndex = machines.value.findIndex(m => m.id === machineId)\n      if (machineIndex !== -1) {\n        machines.value[machineIndex] = { ...machines.value[machineIndex], ...response.data }\n        updateMetrics()\n      }\n      \n      return { success: true, data: response.data }\n    } catch (err) {\n      const apiError = handleAPIError(err)\n      logger.error(`Erro ao buscar status da máquina ${machineId}:`, err)\n      return { success: false, error: apiError.message }\n    }\n  }\n  \n  const registerMachine = async (machineData) => {\n    loading.value = true\n    error.value = null\n    \n    try {\n      const response = await machinesAPI.register(machineData)\n      \n      // Adicionar nova máquina à lista\n      machines.value.push(response.data)\n      updateMetrics()\n      \n      return { success: true, data: response.data }\n    } catch (err) {\n      const apiError = handleAPIError(err)\n      error.value = 'Erro ao registrar máquina: ' + apiError.message\n      logger.error('Erro ao registrar máquina:', err)\n      return { success: false, error: apiError.message }\n    } finally {\n      loading.value = false\n    }\n  }\n  \n  const updateMachineStatus = async (statusData) => {\n    try {\n      const response = await machinesAPI.updateStatus(statusData)\n      \n      // Atualizar máquina na lista\n      const machineIndex = machines.value.findIndex(m => m.id === statusData.machineId)\n      if (machineIndex !== -1) {\n        machines.value[machineIndex] = { ...machines.value[machineIndex], ...response.data }\n        updateMetrics()\n        \n        // Adicionar ao histórico de performance\n        addPerformanceData(statusData.machineId, response.data)\n      }\n      \n      return { success: true, data: response.data }\n    } catch (err) {\n      const apiError = handleAPIError(err)\n      logger.error('Erro ao atualizar status da máquina:', err)\n      return { success: false, error: apiError.message }\n    }\n  }\n  \n  const selectMachine = (machine) => {\n    selectedMachine.value = machine\n  }\n  \n  const clearSelection = () => {\n    selectedMachine.value = null\n  }\n  \n  const setFilters = (newFilters) => {\n    filters.value = { ...filters.value, ...newFilters }\n  }\n  \n  const clearFilters = () => {\n    filters.value = {\n      status: 'all',\n      location: '',\n      department: '',\n      search: ''\n    }\n  }\n  \n  const updateMetrics = () => {\n    const total = machines.value.length\n    const online = machines.value.filter(m => m.status === 'online').length\n    const offline = machines.value.filter(m => m.status === 'offline').length\n    const warning = machines.value.filter(m => m.status === 'warning').length\n    const critical = machines.value.filter(m => m.status === 'critical').length\n    \n    // Calcular médias de performance\n    const onlineMachinesData = machines.value.filter(m => m.status === 'online' && m.performance)\n    const avgCpu = onlineMachinesData.length > 0 \n      ? onlineMachinesData.reduce((sum, m) => sum + (m.performance?.cpu || 0), 0) / onlineMachinesData.length\n      : 0\n    const avgMemory = onlineMachinesData.length > 0\n      ? onlineMachinesData.reduce((sum, m) => sum + (m.performance?.memory || 0), 0) / onlineMachinesData.length\n      : 0\n    const avgDisk = onlineMachinesData.length > 0\n      ? onlineMachinesData.reduce((sum, m) => sum + (m.performance?.disk || 0), 0) / onlineMachinesData.length\n      : 0\n    \n    metrics.value = {\n      totalMachines: total,\n      onlineMachines: online,\n      offlineMachines: offline,\n      warningMachines: warning,\n      criticalMachines: critical,\n      avgCpuUsage: Math.round(avgCpu * 100) / 100,\n      avgMemoryUsage: Math.round(avgMemory * 100) / 100,\n      avgDiskUsage: Math.round(avgDisk * 100) / 100,\n      systemUptime: total > 0 ? Math.round((online / total) * 100 * 100) / 100 : 0\n    }\n  }\n  \n  const addPerformanceData = (machineId, data) => {\n    if (!performanceHistory.value[machineId]) {\n      performanceHistory.value[machineId] = []\n    }\n    \n    const history = performanceHistory.value[machineId]\n    history.push({\n      timestamp: new Date(),\n      cpu: data.performance?.cpu || 0,\n      memory: data.performance?.memory || 0,\n      disk: data.performance?.disk || 0,\n      network: data.performance?.network || 0\n    })\n    \n    // Manter apenas os últimos 100 pontos\n    if (history.length > 100) {\n      history.splice(0, history.length - 100)\n    }\n  }\n  \n  const generateMockMachines = () => {\n    const statuses = ['online', 'offline', 'warning', 'critical']\n    const locations = ['Sede', 'Filial 1', 'Filial 2', 'Home Office']\n    const departments = ['TI', 'Financeiro', 'RH', 'Vendas', 'Marketing']\n    \n    return Array.from({ length: 25 }, (_, i) => ({\n      id: `machine-${i + 1}`,\n      name: `Máquina ${i + 1}`,\n      hostname: `PC-${String(i + 1).padStart(3, '0')}`,\n      ip: `192.168.1.${i + 10}`,\n      status: statuses[Math.floor(Math.random() * statuses.length)],\n      location: locations[Math.floor(Math.random() * locations.length)],\n      department: departments[Math.floor(Math.random() * departments.length)],\n      user: `usuario${i + 1}`,\n      os: 'Windows 11 Pro',\n      lastSeen: new Date(Date.now() - Math.random() * 3600000),\n      performance: {\n        cpu: Math.round(Math.random() * 100),\n        memory: Math.round(Math.random() * 100),\n        disk: Math.round(Math.random() * 100),\n        network: Math.round(Math.random() * 100)\n      },\n      hardware: {\n        processor: 'Intel Core i7-12700K',\n        memory: '16 GB DDR4',\n        storage: '512 GB SSD',\n        graphics: 'NVIDIA RTX 3060'\n      },\n      uptime: Math.floor(Math.random() * 720) // horas\n    }))\n  }\n  \n  // Auto-refresh\n  let refreshInterval = null\n  \n  const startAutoRefresh = () => {\n    if (monitoringConfig.value.autoRefresh && !refreshInterval) {\n      refreshInterval = setInterval(() => {\n        fetchMachines()\n      }, monitoringConfig.value.refreshRate)\n    }\n  }\n  \n  const stopAutoRefresh = () => {\n    if (refreshInterval) {\n      clearInterval(refreshInterval)\n      refreshInterval = null\n    }\n  }\n  \n  // WebSocket\n  const connectWebSocket = async () => {\n    try {\n      // Get auth token from auth store\n      const authStore = useAuthStore()\n      const token = authStore.token\n      \n      // Build WebSocket URL with token\n      const wsUrl = token \n        ? `ws://localhost:8000/api/v1/ws?token=${token}`\n        : 'ws://localhost:8000/api/v1/ws'\n      \n      await websocketService.connect(wsUrl)\n      \n      // Listeners para eventos WebSocket\n      websocketService.on('connected', () => {\n        wsConnected.value = true\n        logger.info('WebSocket conectado - solicitando dados iniciais')\n        websocketService.send('subscribe', { type: 'machines' })\n      })\n\n      websocketService.on('disconnected', () => {\n        wsConnected.value = false\n        logger.warn('WebSocket desconectado')\n      })\n\n      websocketService.on('machine_update', ({ data }) => {\n        handleMachineUpdate(data)\n      })\n\n      websocketService.on('machine_metrics', ({ data }) => {\n        handleMachineMetrics(data)\n      })\n\n      websocketService.on('machine_alert', ({ data }) => {\n        handleMachineAlert(data)\n      })\n\n      websocketService.on('machines_list', ({ data }) => {\n        handleMachinesList(data)\n      })\n\n      websocketService.on('error', ({ error }) => {\n        logger.error('Erro no WebSocket:', error)\n        wsConnected.value = false\n      })\n\n    } catch (error) {\n      logger.error('Erro ao conectar WebSocket:', error)\n      wsConnected.value = false\n    }\n  }\n\n  const disconnectWebSocket = () => {\n    websocketService.disconnect()\n    wsConnected.value = false\n  }\n\n  // Handlers para mensagens WebSocket\n  const handleMachineUpdate = (data) => {\n    const { machineId, updates } = data\n    const machineIndex = machines.value.findIndex(m => m.id === machineId)\n    \n    if (machineIndex !== -1) {\n      // Atualiza máquina existente\n      machines.value[machineIndex] = {\n        ...machines.value[machineIndex],\n        ...updates,\n        lastUpdate: new Date().toISOString()\n      }\n      logger.debug(`Máquina ${machineId} atualizada via WebSocket`)\n    } else {\n      // Adiciona nova máquina\n      machines.value.push({\n        id: machineId,\n        ...updates,\n        lastUpdate: new Date().toISOString()\n      })\n      logger.debug(`Nova máquina ${machineId} adicionada via WebSocket`)\n    }\n    \n    lastUpdate.value = new Date().toISOString()\n  }\n\n  const handleMachineMetrics = (data) => {\n    const { machineId, metrics } = data\n    \n    // Atualiza métricas da máquina\n    const machine = machines.value.find(m => m.id === machineId)\n    if (machine) {\n      machine.metrics = {\n        ...machine.metrics,\n        ...metrics,\n        timestamp: new Date().toISOString()\n      }\n      \n      // Adiciona ao histórico de performance\n      addPerformanceData(machineId, metrics)\n    }\n    \n    // Atualiza métricas agregadas\n    updateAggregatedMetrics()\n  }\n\n  const handleMachineAlert = (data) => {\n    const { machineId, alert } = data\n    \n    // Adiciona alerta\n    alerts.value.unshift({\n      id: Date.now(),\n      machineId,\n      ...alert,\n      timestamp: new Date().toISOString(),\n      read: false\n    })\n    \n    // Mantém apenas os últimos 100 alertas\n    if (alerts.value.length > 100) {\n      alerts.value = alerts.value.slice(0, 100)\n    }\n    \n    logger.info(`Novo alerta para máquina ${machineId}:`, alert)\n  }\n\n  const handleMachinesList = (data) => {\n    const { machines: machinesList } = data\n    \n    // Atualiza lista completa de máquinas\n    machines.value = machinesList.map(machine => ({\n      ...machine,\n      lastUpdate: new Date().toISOString()\n    }))\n    \n    lastUpdate.value = new Date().toISOString()\n    updateAggregatedMetrics()\n    \n    logger.info(`Lista de máquinas atualizada via WebSocket: ${machinesList.length} máquinas`)\n  }\n  \n  const updateMonitoringConfig = (newConfig) => {\n    monitoringConfig.value = { ...monitoringConfig.value, ...newConfig }\n    \n    // Reiniciar auto-refresh se necessário\n    if (monitoringConfig.value.autoRefresh) {\n      stopAutoRefresh()\n      startAutoRefresh()\n    } else {\n      stopAutoRefresh()\n    }\n  }\n  \n  // Retorno do store\n  return {\n    // Estado\n    machines,\n    selectedMachine,\n    loading,\n    error,\n    lastUpdate,\n    wsConnected,\n    wsError,\n    filters,\n    monitoringConfig,\n    metrics,\n    alerts,\n    performanceHistory,\n    \n    // Computed\n    filteredMachines,\n    onlineMachines,\n    offlineMachines,\n    criticalMachines,\n    warningMachines,\n    \n    // Actions\n    fetchMachines,\n    fetchMachineStatus,\n    registerMachine,\n    updateMachineStatus,\n    selectMachine,\n    clearSelection,\n    setFilters,\n    clearFilters,\n    updateMetrics,\n    addPerformanceData,\n    connectWebSocket,\n    disconnectWebSocket,\n    startAutoRefresh,\n    stopAutoRefresh,\n    updateMonitoringConfig,\n    \n    // WebSocket handlers\n    handleMachineUpdate,\n    handleMachineMetrics,\n    handleMachineAlert,\n    handleMachinesList\n  }\n})"],"names":["websocketService","constructor","this","ws","url","reconnectAttempts","maxReconnectAttempts","reconnectInterval","isConnecting","isManualClose","listeners","Map","heartbeatInterval","heartbeatTimeout","lastHeartbeat","config","reconnectDelay","connect","options","readyState","WebSocket","CONNECTING","logger","warn","Promise","resolve","OPEN","reject","info","connectionTimeout","setTimeout","close","Error","timeout","onopen","event","clearTimeout","emit","startHeartbeat","onmessage","data","JSON","parse","handleMessage","error","rawData","onclose","stopHeartbeat","code","reason","shouldReconnect","scheduleReconnect","onerror","disconnect","send","type","isConnected","message","timestamp","Date","now","stringify","debug","on","callback","has","set","Set","get","add","off","delete","forEach","messageData","handleHeartbeatResponse","setInterval","clearInterval","latency","delay","Math","pow","catch","getStats","Array","from","keys","useMachinesStore","defineStore","machines","ref","selectedMachine","loading","lastUpdate","wsConnected","wsError","filters","status","location","department","search","monitoringConfig","autoRefresh","refreshRate","realTimeUpdates","alertsEnabled","metrics","totalMachines","onlineMachines","offlineMachines","warningMachines","criticalMachines","avgCpuUsage","avgMemoryUsage","avgDiskUsage","systemUptime","alerts","performanceHistory","filteredMachines","computed","filtered","value","filter","machine","_a","toLowerCase","includes","searchTerm","name","_b","hostname","_c","ip","_d","user","fetchMachines","async","forceRefresh","response","cachedAPI","getAll","cacheKey","cacheTTL","updateMetrics","success","err","apiError","handleAPIError","total","length","online","m","offline","warning","critical","onlineMachinesData","performance","avgCpu","reduce","sum","cpu","avgMemory","memory","avgDisk","disk","round","addPerformanceData","machineId","history","push","network","splice","refreshInterval","startAutoRefresh","stopAutoRefresh","handleMachineUpdate","updates","machineIndex","findIndex","id","toISOString","handleMachineMetrics","find","updateAggregatedMetrics","handleMachineAlert","alert","unshift","read","slice","handleMachinesList","machinesList","map","fetchMachineStatus","getStatus","registerMachine","machineData","machinesAPI","register","updateMachineStatus","statusData","updateStatus","selectMachine","clearSelection","setFilters","newFilters","clearFilters","connectWebSocket","token","useAuthStore","wsUrl","disconnectWebSocket","updateMonitoringConfig","newConfig"],"mappings":"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"}