import { ref, computed, watch } from 'vue'

export function usePagination(options = {}) {
  const {
    initialPage = 1,
    initialPageSize = 20,
    pageSizeOptions = [10, 20, 50, 100],
    maxVisiblePages = 5,
    showSizeChanger = true,
    showQuickJumper = true,
    showTotal = true
  } = options

  // Reactive state
  const currentPage = ref(initialPage)
  const pageSize = ref(initialPageSize)
  const total = ref(0)
  const loading = ref(false)

  // Computed properties
  const totalPages = computed(() => Math.ceil(total.value / pageSize.value))
  
  const startIndex = computed(() => (currentPage.value - 1) * pageSize.value)
  const endIndex = computed(() => Math.min(startIndex.value + pageSize.value, total.value))
  
  const hasNext = computed(() => currentPage.value < totalPages.value)
  const hasPrev = computed(() => currentPage.value > 1)
  
  const visiblePages = computed(() => {
    const pages = []
    const half = Math.floor(maxVisiblePages / 2)
    
    let start = Math.max(1, currentPage.value - half)
    let end = Math.min(totalPages.value, start + maxVisiblePages - 1)
    
    // Adjust start if we're near the end
    if (end - start + 1 < maxVisiblePages) {
      start = Math.max(1, end - maxVisiblePages + 1)
    }
    
    for (let i = start; i <= end; i++) {
      pages.push(i)
    }
    
    return pages
  })
  
  const paginationInfo = computed(() => ({
    current: currentPage.value,
    pageSize: pageSize.value,
    total: total.value,
    totalPages: totalPages.value,
    startIndex: startIndex.value,
    endIndex: endIndex.value,
    hasNext: hasNext.value,
    hasPrev: hasPrev.value
  }))

  // Methods
  const goToPage = (page) => {
    if (page < 1 || page > totalPages.value || page === currentPage.value) {
      return false
    }
    
    currentPage.value = page
    return true
  }

  const nextPage = () => {
    return goToPage(currentPage.value + 1)
  }

  const prevPage = () => {
    return goToPage(currentPage.value - 1)
  }

  const firstPage = () => {
    return goToPage(1)
  }

  const lastPage = () => {
    return goToPage(totalPages.value)
  }

  const changePageSize = (newSize) => {
    if (pageSizeOptions.includes(newSize) && newSize !== pageSize.value) {
      const currentItem = startIndex.value
      pageSize.value = newSize
      
      // Adjust current page to maintain position
      const newPage = Math.floor(currentItem / newSize) + 1
      currentPage.value = Math.max(1, Math.min(newPage, totalPages.value))
      
      return true
    }
    return false
  }

  const setTotal = (newTotal) => {
    total.value = newTotal
    
    // Adjust current page if it's out of bounds
    if (currentPage.value > totalPages.value && totalPages.value > 0) {
      currentPage.value = totalPages.value
    }
  }

  const reset = () => {
    currentPage.value = initialPage
    pageSize.value = initialPageSize
    total.value = 0
    loading.value = false
  }

  // Advanced pagination features
  const jumpToPage = (page) => {
    const pageNum = parseInt(page)
    if (isNaN(pageNum)) return false
    
    return goToPage(pageNum)
  }

  const getPageRange = (page = currentPage.value) => {
    const start = (page - 1) * pageSize.value
    const end = Math.min(start + pageSize.value - 1, total.value - 1)
    return { start, end }
  }

  const isPageVisible = (page) => {
    return visiblePages.value.includes(page)
  }

  const getPageOffset = (page = currentPage.value) => {
    return (page - 1) * pageSize.value
  }

  // Infinite scroll support
  const hasMoreData = computed(() => endIndex.value < total.value)
  
  const loadNextPage = async (loadFunction) => {
    if (!hasNext.value || loading.value) return null
    
    loading.value = true
    try {
      const nextPageData = await loadFunction(currentPage.value + 1, pageSize.value)
      nextPage()
      return nextPageData
    } catch (error) {
      console.error('Error loading next page:', error)
      throw error
    } finally {
      loading.value = false
    }
  }

  // URL synchronization
  const syncWithURL = (router, route) => {
    // Read from URL
    const urlPage = parseInt(route.query.page) || initialPage
    const urlPageSize = parseInt(route.query.pageSize) || initialPageSize
    
    currentPage.value = urlPage
    if (pageSizeOptions.includes(urlPageSize)) {
      pageSize.value = urlPageSize
    }
    
    // Watch for changes and update URL
    watch([currentPage, pageSize], ([newPage, newPageSize]) => {
      const query = { ...route.query }
      
      if (newPage !== initialPage) {
        query.page = newPage
      } else {
        delete query.page
      }
      
      if (newPageSize !== initialPageSize) {
        query.pageSize = newPageSize
      } else {
        delete query.pageSize
      }
      
      router.replace({ query })
    })
  }

  // Performance optimization
  const debouncePageChange = (callback, delay = 300) => {
    let timeoutId
    
    return (...args) => {
      clearTimeout(timeoutId)
      timeoutId = setTimeout(() => callback(...args), delay)
    }
  }

  // Accessibility helpers
  const getPageAriaLabel = (page) => {
    if (page === currentPage.value) {
      return `Página ${page}, página atual`
    }
    return `Ir para página ${page}`
  }

  const getPaginationAriaLabel = () => {
    return `Navegação de páginas, página ${currentPage.value} de ${totalPages.value}`
  }

  const getPageSizeAriaLabel = () => {
    return `Itens por página: ${pageSize.value}`
  }

  // Data slicing for client-side pagination
  const sliceData = (data) => {
    if (!Array.isArray(data)) return []
    
    const start = startIndex.value
    const end = endIndex.value
    
    return data.slice(start, end)
  }

  // Statistics
  const getStatistics = () => {
    return {
      totalItems: total.value,
      totalPages: totalPages.value,
      currentPage: currentPage.value,
      pageSize: pageSize.value,
      itemsOnCurrentPage: Math.min(pageSize.value, total.value - startIndex.value),
      startItem: startIndex.value + 1,
      endItem: endIndex.value,
      percentageComplete: total.value > 0 ? (endIndex.value / total.value) * 100 : 0
    }
  }

  // Validation
  const validatePageSize = (size) => {
    return pageSizeOptions.includes(size)
  }

  const validatePage = (page) => {
    return page >= 1 && page <= totalPages.value
  }

  // Export reactive state and methods
  return {
    // Reactive state
    currentPage,
    pageSize,
    total,
    loading,
    
    // Computed
    totalPages,
    startIndex,
    endIndex,
    hasNext,
    hasPrev,
    visiblePages,
    paginationInfo,
    hasMoreData,
    
    // Basic methods
    goToPage,
    nextPage,
    prevPage,
    firstPage,
    lastPage,
    changePageSize,
    setTotal,
    reset,
    
    // Advanced methods
    jumpToPage,
    getPageRange,
    isPageVisible,
    getPageOffset,
    loadNextPage,
    syncWithURL,
    debouncePageChange,
    sliceData,
    
    // Accessibility
    getPageAriaLabel,
    getPaginationAriaLabel,
    getPageSizeAriaLabel,
    
    // Utilities
    getStatistics,
    validatePageSize,
    validatePage,
    
    // Options
    pageSizeOptions,
    maxVisiblePages,
    showSizeChanger,
    showQuickJumper,
    showTotal
  }
}

// Helper function for server-side pagination
export function createPaginationParams(pagination) {
  return {
    page: pagination.currentPage,
    limit: pagination.pageSize,
    offset: pagination.startIndex
  }
}

// Helper function for handling pagination response
export function handlePaginationResponse(pagination, response) {
  const { data, total, page, pageSize } = response
  
  pagination.setTotal(total)
  
  if (page && page !== pagination.currentPage) {
    pagination.goToPage(page)
  }
  
  if (pageSize && pageSize !== pagination.pageSize) {
    pagination.changePageSize(pageSize)
  }
  
  return data
}